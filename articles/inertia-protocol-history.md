---
title: "Inertiaプロトコル：なぜViewは分離され、キメラが生まれ、そしてミニマムに回帰したか"
emoji: "🔄"
type: "tech"
topics: ["rails", "inertia", "turbo", "react", "spa"]
published: true
---

## Viewが一番遅かった時代

かつてWebアプリケーションのボトルネックはViewだった。

PHPの時代、HTMLの中にPHPが埋め込まれていた。Rubyの時代も同じだ。ERBやHAMLの中で、ループを回し、条件分岐を書き、ヘルパを呼び出していた。

```erb
<% @users.each do |user| %>
  <% if user.active? %>
    <%= render partial: 'user_card', locals: { user: user } %>
  <% end %>
<% end %>
```

このコードは毎リクエスト、サーバー上で実行される。データベースから取得したオブジェクトをループし、条件を評価し、パーシャルを読み込み、文字列を結合し、HTMLを組み立てる。すべてがサーバーのCPUとメモリを消費する。

Viewはアプリケーションの「末端」に見えて、実は最もリソースを食う場所だった。

---

## 分離への衝動：API + SPAの誕生

だから分離した。

「Viewをサーバーでレンダリングするのをやめればいいじゃないか」

サーバーはAPIだけを提供する。JSONを返すだけ。レンダリングはクライアント（ブラウザ）に任せる。こうして生まれたのがSPAアーキテクチャだ。

```
[従来]
Browser → Rails → DB → Rails(View) → HTML → Browser

[SPA]
Browser → Rails(API) → DB → JSON → Browser(React) → DOM
```

理論的には美しかった。サーバーの負荷が減る。フロントエンドとバックエンドを独立してスケールできる。チームも分けられる。

しかし現実は違った。

---

## SPAの代償：二重帝国の統治コスト

完全なSPAには代償がある。

**ルーティングの二重管理**
サーバー側のルーティングと、クライアント側のルーティング。両方を管理しなければならない。React Routerで定義したルートが、Rails側のルートと整合しているか。404はどちらが返すのか。

**認証の複雑化**
セッションベースの認証は使いにくくなる。JWTを導入する。トークンの保存場所は？リフレッシュトークンの管理は？CSRFはどうする？

**初期表示の問題**
SPAは初期ロードが遅い。JavaScriptをダウンロードし、実行し、APIを叩き、データを取得し、やっと画面が描画される。SEOも厳しい。SSRを導入する。Next.jsを入れる。サーバーでReactを動かす。あれ、またサーバーでViewをレンダリングしている…？

**状態管理の肥大化**
サーバーの状態とクライアントの状態を同期させる必要がある。Redux。Recoil。TanStack Query。状態管理ライブラリが乱立し、どれを選ぶかで議論が起きる。

小さなチームが、二つの王国を同時に統治することになる。

---

## React Railsの苦悩

「分離しすぎるのが問題なら、Railsの中にReactを埋め込めばいいのでは」

react-railsやwebpackerが生まれた。ERBの中にReactコンポーネントを埋め込める。

```erb
<%= react_component("UserList", { users: @users }) %>
```

しかしこれも困難だった。

- webpackerの設定地獄
- アセットパイプラインとの競合
- propsの受け渡しで型が消える
- サーバーサイドレンダリングを入れると複雑化
- Railsのアップグレードで動かなくなる

Reactを「埋め込む」というアプローチは、二つの世界を無理やり接着しているだけだった。境界が曖昧で、どちらの流儀に従うべきかわからない。

---

## Turbo：キメラの誕生

Basecampは別の道を選んだ。

「JavaScriptフレームワークを使わずに、SPAライクな体験を実現できないか」

Turboが生まれた。Turbo Drive、Turbo Frames、Turbo Streams。HTMLをサーバーで生成し続けながら、ページ遷移を高速化し、部分更新を可能にする。

思想は美しい。「HTMLオーバー・ザ・ワイヤー」。サーバーがHTMLを返し、クライアントはそれを受け取って差し替えるだけ。JavaScriptを書かなくていい。Reactを学ばなくていい。

しかし現実は複雑だった。

```erb
<%= turbo_frame_tag "user_#{user.id}" do %>
  <%= render user %>
<% end %>
```

```ruby
respond_to do |format|
  format.turbo_stream { render turbo_stream: turbo_stream.replace(@user) }
  format.html { redirect_to @user }
end
```

Turboは強力だが、学習曲線は急だ。Turbo Framesの入れ子、Turbo Streamsのブロードキャスト、Stimulusとの連携。「JavaScriptを書かなくていい」と言いながら、Stimulusというコントローラーを書くことになる。

結局、新しいパラダイムを学ぶ必要がある。そしてそのパラダイムは、Railsの外では通用しない。Reactのエコシステムは使えない。Vue.jsのライブラリも使えない。Turboの世界に閉じ込められる。

キメラは強力だが、キメラを飼いならすには覚悟がいる。

---

## Inertiaプロトコル：ミニマムな回帰

そしてInertiaが現れた。

Inertiaは「プロトコル」だ。フレームワークではない。ライブラリではない。サーバーとクライアントの間の「約束事」だ。

その約束はシンプル：

1. **最初のリクエスト**：サーバーは完全なHTMLを返す（普通のWebアプリと同じ）
2. **以降のナビゲーション**：`X-Inertia: true`ヘッダー付きでリクエストし、サーバーはJSONを返す
3. **JSONの中身**：コンポーネント名とprops、それだけ

```json
{
  "component": "Users/Index",
  "props": {
    "users": [...]
  },
  "url": "/users",
  "version": "abc123"
}
```

これだけ。

---

## Inertiaが解決したこと

**ルーティングはサーバーに一元化**
React Routerは不要。URLの設計はRailsのroutes.rbで完結する。フロントエンドは「このコンポーネントを描画しろ」と言われたら描画するだけ。

**認証もサーバーに一元化**
セッションベースの認証がそのまま使える。JWTは不要。before_actionでauthenticate_user!すればいい。いつものRailsのまま。

**初期表示も速い**
最初のリクエストは完全なHTMLを返す。SSRを別途構築する必要がない。SEOも問題ない。

**状態管理は最小限**
サーバーが毎回必要なデータをpropsで渡してくれる。クライアントで状態を管理する必要がほとんどない。フォームの入力中状態くらい。

**Reactのエコシステムが使える**
UIはReact（またはVue、Svelte）で書く。普通のReactコンポーネント。普通のhooks。普通のライブラリ。Turboの世界に閉じ込められない。

---

## プロトコルとしてのミニマリズム

Inertiaの本質は「プロトコル」であることにある。

TurboはRailsの思想を拡張した。「HTMLをサーバーで生成し続ける」という前提を守りながら、SPAライクな体験を実現しようとした。だから複雑になった。HTMLとJavaScriptの境界を曖昧にし、両方の知識が必要になった。

Inertiaは違う。「サーバーはコントローラーまで、クライアントはViewから」と明確に線を引いた。

```
[Inertia]
Browser → Rails(Controller) → JSON → Browser(React) → DOM
```

サーバーは何を描画するか（コンポーネント名）と、何のデータで描画するか（props）だけを決める。どう描画するかはクライアントの責務。

この境界の明確さが、Inertiaのミニマリズムを支えている。

---

## Turboの思想のミニマム実装

InertiaはTurboの思想を引き継いでいる。

- サーバーサイドルーティングを維持する
- セッションベースの認証を維持する
- 初期表示をサーバーで完結させる

違いは「HTMLを返すか、JSONを返すか」。

Turboは「HTMLを返すが、JavaScriptで差し替える」。だからHTMLの構造とJavaScriptの振る舞いの両方を考える必要があった。

Inertiaは「JSONを返し、クライアントがレンダリングする」。だからサーバーはデータに集中し、クライアントはUIに集中できる。

同じ思想の、よりミニマムな実装。それがInertiaだ。

---

## 歴史は繰り返す、らせん状に

振り返ってみる。

1. **混沌**：PHPやERBがViewの中でロジックを実行
2. **分離**：API + SPAで完全に分離
3. **統合の試み**：React Railsで無理やり接着
4. **キメラ**：Turboで新しいパラダイムを構築
5. **ミニマムな回帰**：Inertiaでシンプルなプロトコルに

歴史は完全には繰り返さない。らせん状に進む。

InertiaはERB時代の「サーバーがすべてを制御する」という感覚を取り戻しながら、SPAの「リッチなクライアントUI」を手に入れた。両方の良いとこ取り。しかし、それは妥協ではない。境界を明確にすることで、複雑さを最小化した設計だ。

---

## いつInertiaを選ぶか

- 小〜中規模のチーム（フロントエンド専任がいない、または少ない）
- Railsの生産性を維持したい
- Reactのエコシステムを使いたい
- SSR構築の複雑さを避けたい
- 状態管理の複雑さを避けたい

逆に、こういう場合はInertiaでなくてもいい：

- 大規模なSPAで、クライアントサイドの状態管理が複雑に必要
- モバイルアプリとAPIを共有する必要がある
- マイクロフロントエンドのような分散アーキテクチャ

---

## 終わりに

Viewが遅いから分離した。分離したら複雑になった。複雑さを隠そうとしてキメラが生まれた。キメラを飼いならすのは大変だった。

Inertiaはその歴史を踏まえた、ミニマムな解答だ。

「サーバーはコントローラーまで。クライアントはViewから」

このシンプルな約束が、多くの複雑さを解消する。

Webアプリケーション開発の歴史は、「どこに境界を引くか」の試行錯誤だった。Inertiaは、その境界をもっとも自然な場所に引いたプロトコルだと思う。
