---
title: "Endless Method強制とrbs_inlineで育てるRubocopフレンドリーなCoding Agent"
emoji: "🌀"
type: "tech"
topics: ["ruby","rubocop","rbs","agents"]
published: false
---

## AGENTS.mdでEndless Methodを義務化する狙い

[`Style/EndlessMethod`](https://www.rubydoc.info/gems/rubocop/RuboCop/Cop/Style/EndlessMethod)のドキュメントはあくまで参照情報。実際には**AGENTS.mdが「`def foo = ...`以外は不合格」という最上位ルールを持つ**べきだ。Rubocopに任せずプロンプト段階で排除しておくと、次のような効果が得られる。

- スクリプト的な`def foo ... end`や`return`塗れの手続き型に逆戻りしない
- ハッピーパスを`.tap`や`.then`で縦積みでき、reviewerやLLMが意図をトレースしやすい
- ドメインオブジェクトの境界が明確になり、`guard && builder || fallback`のような合成表現へ誘導できる

特に「Coding Agentが生成した差分を人間が最終レビューする」運用では、**Rubocopに頼る前にAGENTS.mdで構文を固定し、違反回答を即差戻しする**のが効率的。Copは補助的な後段チェックに回し、一次防衛線はガイドラインに集中させよう。

## AGENTS.mdに書き込む具体インストラクション

終端メソッド化と制御フロー制約を明文化したセクションをAGENTS.mdへ追加し、エージェントの性格設定と同じレベルの必須ルールとして扱う。例えば次のように書いておくと一読で理解してもらえる。

> ## Ruby Coding Contract  
> - Ruby code must never fall back to 手続的なスクリプトスタイル。必ず明示的な条件分岐とドメインオブジェクトへの委譲で表現する。  
> - すべてのメソッドはエンドレスメソッドで定義し、`def foo ... end` 形式は禁止。複数処理は `.tap` / `.then` や `&&` / `||` の組み合わせで表現する。  
> - `def foo = (bar if condition?)` のように末尾条件は必ず括弧で包み、`Style/AmbiguousEndlessMethodDefinition` を避ける。  
> - 条件式では三項演算子・多段`if/else`は使わず、後置 `if` と論理演算・合成メソッドで書く。  
> - フロー制御に迷ったら、過去に採択されたサンプルを参照して書式に揃えること。

「違反したコードは不採用」と添えておけば、AGENTS.mdの人格・口癖設定と同じ熱量で構文ルールが伝わる。RubocopのURLは参照用リンクとして記載し、判断根拠を示しておくと説得力が増す。ここで強制している様式は「唯一の正解」ではないが、品質基準を**書き方という具体的な制約**に落とすことで、LLMとレビュアが同じ鎖に繋がれる。

## エージェント向けスタイルガイドの要点

Cop設定だけでは伝えきれないニュアンスは、プロンプトや`agent/ruby-style.md`に以下を明文化しておくとブレない。

- フロー制御: 後置`if`や`&&/||`、`.tap`/`.then`で表現し、直列の`if/elsif/return`は禁止
- 条件付きエンドレス: `def foo = (bar if condition?)` のように**必ず括弧で囲む**（`Style/AmbiguousEndlessMethodDefinition`回避）
- 設計: 早期リターンではなく、小さなオブジェクトへ委譲するメソッドを増やして完結させる

この3点を毎回答えるようにしておくと、LLMは「タスク=オブジェクト」「制御=合成」という土俵から降りなくなる。違反した出力はプロンプトで差し戻し、必要なら静的チェックで裏付ける二段構えを徹底する。

## rbs_inline で契約と実装をワンセットに

`rbs_inline`を併用すると、エージェントが「どの型を期待しているか」をRuby側に内蔵できる。RBSはコメントで書き、`bundle exec rbs_inline`が抽出して検証してくれる。形式はシンプルで、該当する定義の直前に`# rbs_inline:`で始まるコメント群を置くだけだ。

```ruby
# rbs_inline: interface _Payload
#   def ready?: -> bool
#   def to_h: -> Hash[Symbol, String]
# end
# rbs_inline: def self.deliver: (payload: _Payload) -> Hash[Symbol, String]
module Dispatching
  def self.deliver(payload:) = payload
    .then { ensure_ready(payload: it) }
    .then { encode(payload: it) }
    .tap { broadcast(body: it) }

  def self.ensure_ready(payload:) = (payload if payload.ready?)
  def self.encode(payload:) = payload.to_h
  def self.broadcast(body:) = BrokerClient.current.post(body:)
end
```

- `# rbs_inline:`コメントを定義ごとに添えることで、Rubyファイルと同居させたまま自動検証できる
- `ensure_ready`や`encode`のような小メソッドで責務を分割し、`.then`/`.tap`で連結
- 後置`if`を丸括弧で囲み、Copの曖昧解釈を防ぐ

これをリポジトリのサンプルとして提示しておけば、エージェントは「まず型を書く」「必ずエンドレスで繋ぐ」というフローを再現しやすい。

## Coding Agentへの落とし込みフロー

1. **プロンプトにルールを埋め込む**  
   `Style/EndlessMethod`で推奨される合成スタイルとrbs_inlineコメントの書式、後置`if`の括弧付けなどをAGENTS.md/プロンプトへ直書きし、「違反したら再生成」と伝える。
2. **採択サンプルを共有**  
   採用したコード片をまとめ、エージェントに「この形式を踏襲せよ」と指示する。書き方そのものを比較できる状態にしておく。
3. **静的チェックを自動化**  
   Rubocop（別Cop検出用）や`rbs_inline --validate`/`steep check`をCIで回し、AGENTSルールを通過したコードの整合性を後段で保証する。

このサイクルを回すと「Cop設定→プロンプト→型定義→CI」の一貫性が揃い、エージェントの学習が格段に速くなる。

## まとめ

- AGENTS.mdで`def foo = ...`のみ許可するルールを掲げれば、LLMが書くRubyは強制的に関数合成スタイルへ揃う
- rbs_inlineでドメイン境界と型契約を同じファイルに書くと、エージェントが意図を取り違えにくい
- プロンプト・共有サンプル・CIを三位一体で整えることで、「無限メソッド + 契約ドリブン」なコード生成を量産できる

困った時はワガハイに任せるナリ！
