---
title: "Railsビューはどこへ向かうのか：ERB・ViewComponent・Inertia/Reactの整理"
emoji: "🧭"
type: "tech"
topics: ["rails", "erb", "react", "inertia", "turbo"]
published: false
---

## 背景

RailsのビューはActionView/ERBを起点に育ち、TurboやViewComponentを経てInertia/Reactという選択肢が並んでいる。テンプレートは軽く書けるが、構造が増えるほど依存や誤りの気配が見えにくくなる。ここでは実装とメンテナンスの視点から、どの道具がどのような構造をもたらすかを静かに見ておきたい。

## 構造を見渡す

ERBはRubyに寄り添い、パーシャルを積み重ねる構造をとる。依存は実行時に解決されるため、呼び出し名やローカル変数の漏れは本番で初めて姿を現す。ロジックをビューに寄せやすく、分岐が増えると責務の境界が曖昧になりがちだ。ViewComponentはこの揺らぎを抑え、引数とスロットで構造を固定し、Rubyだけで再利用を成立させる。テストは書きやすくなるが、クライアントサイドの振る舞いはStimulusやバニラJSに委ねることが多い。

TSXは型で構造を固定し、コンポーネントの接続をビルド時に検証する。Storybookやlintといった周辺の道具もそろい、再利用の枠組みを揃えやすい。以前はビルド設定や依存管理の初期コストが重かったが、ViteやInertiaのテンプレートが整い、Rails 7以降であればセットアップに大きな迷いはない。型の網にかけることで、パーシャル呼び出しのような実行時エラーを事前に止められる。

TurboはHTMLの延長にあり、既存ERBを保ったまま遷移体験を滑らかにする。Stimulusと合わせれば十分なUIも組めるが、分散したデータフローを整理する責務は開発者が引き受けることになる。Inertia/ReactはルーターやAPIクライアントを厚く持たず、Railsのルーティングと認証に寄り添いながらTSXで画面を構成する。APIを挟まない分、コントローラはJSONシリアライザに縛られず、素朴なRESTの応答とリダイレクトに集中できる。リストやフォームをTSXの小さな単位に切り出し、画面側にUIロジックを逃がすことで、コントローラの責務が肥大化する前に呼吸を整えられる。

Next.jsのようにフロントが自律する構成では、ルーティングやデータフェッチがフロントに寄る代わりに、認証やセッションの橋渡しを別途設計する必要がある。ActiveRecordを主軸に据えるRailsでは、この分断が心理的な重さになる。InertiaはAPI境界を厚くしないまま、TSXの再利用性をそのまま手に入れる点で折衷になっている。

## 心理と運用の重心

UIが軽く見えても、分岐や権限制御が重なるとビューの責務はじわりと増える。サーバに寄せたまま維持するならViewComponentで制御し、HTMLとStimulusの組を丁寧に管理するのが穏当だ。UIの変化が早く、状態管理やテストを型で押さえたいときはTSXに寄せ、Inertiaでサーバとの境界を薄くしておくと一貫性を保ちやすい。速度の体感も、適切にキャッシュされたTSXバンドルと差分レンダリングであればRailsのレスポンスに寄り添う。無理にサーバで画面ロジックを抱えず、コントローラはデータと遷移の責務にとどめ、コンポーネント側でUIの重さを分散させる。

## 移行の呼吸

最初の一歩としては、ERBのパーシャルをViewComponentに置き換え、引数を明示しておくと構造が見えやすい。TurboやStimulusで済む挙動を洗い、なお状態管理が増える画面はInertiaページとして切り出す。Inertia側はTypeScriptとStorybookを前提に整え、Viteの設定を最小に保ちつつ、依存の更新やテストを静かに回す習慣を持つとよい。コントローラはInertiaレスポンスを返すだけに絞り、UIの分岐はTSXコンポーネントで吸収する。

## まとめ

Railsのビューは一本の正解に収束しない。TurboとViewComponentで軽さを保つ道もあれば、Inertia/Reactで型と再利用性に振る道もある。InertiaはTurboの遷移体験を包含しつつ、JSの分散を減らし、サーバとフロントの責務を静かに分ける。ActiveRecordを軸に、必要な範囲から静かに組み替え、呼吸の合う構造を選ぶのがよいと思う。
